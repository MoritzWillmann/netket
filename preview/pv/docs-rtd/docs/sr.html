<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Geometric Tensor and Stochastic Reconfiguration &mdash; netket v3.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Drivers API" href="drivers.html" />
    <link rel="prev" title="The Variational State Interface" href="varstate.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> netket<img src="../_static/logonav.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/netket3.html">Ground-State Variational Search with NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/jax.html">Using JAX as a backend in NetKet - Feature Preview for v3.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html">Using a group convolutional neural network to learn the ground-state of a symmetric spin model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#G-CNNs-are-generalizations-of-CNNs-to-non-abelian-groups">G-CNNs are generalizations of CNNs to non-abelian groups</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#Defining-the-Hamiltonian">Defining the Hamiltonian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#Defining-the-GCNN">Defining the GCNN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#Variational-Monte-Carlo">Variational Monte Carlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#Checking-with-ED">Checking with ED</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html#Simulating-A-Larger-Lattice">Simulating A Larger Lattice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/j1j2.html">Variational Monte Carlo with Neural Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/Heisenberg1d.html">Learning the ground-state of a spin model with different Neural Networks available in NetKet</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="superop.html">The Lindblad Master Equation</a></li>
<li class="toctree-l1"><a class="reference internal" href="hilbert.html">The Hilbert module</a></li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">The Operator module</a></li>
<li class="toctree-l1"><a class="reference internal" href="varstate.html">The Variational State Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Geometric Tensor and Stochastic Reconfiguration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#stochastic-reconfiguration">Stochastic Reconfiguration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#using-stochastic-reconfiguration">Using stochastic reconfiguration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="drivers.html">The Drivers API</a></li>
<li class="toctree-l1"><a class="reference internal" href="sharp-bits.html">üî™ The Sharp Bits üî™</a></li>
</ul>
<p class="caption"><span class="caption-text">Extending NetKet</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="custom_models.html">Defining Custom Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_expect.html">Overriding defaults in NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_preconditioners.html">Defining Custom Preconditioners</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_operator.html">Defining Custom Operators</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing-tests.html">Writing Tests</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-stability.html">API Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Public API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-experimental.html">Experimental API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">netket</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quantum Geometric Tensor and Stochastic Reconfiguration</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/docs/sr.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="quantum-geometric-tensor-and-stochastic-reconfiguration">
<span id="qgt-and-sr"></span><h1>Quantum Geometric Tensor and Stochastic Reconfiguration<a class="headerlink" href="#quantum-geometric-tensor-and-stochastic-reconfiguration" title="Permalink to this headline">ÔÉÅ</a></h1>
<p>The Quantum Geometric Tensor (QGT) is the Fubini-Study metric tensor of the manifold on which a variational state is defined.
In the general case (and in practise for any NQS ansatz), the QGT varies depending on the current quantum state and thus needs to be computed when the variational parameters <span class="math notranslate nohighlight">\(W\)</span> change.
To give an example, we consider a variational ansatz <span class="math notranslate nohighlight">\( \psi\colon \mathbb{R} \rightarrow \mathscr{H} \)</span> which maps elements <span class="math notranslate nohighlight">\(W\)</span> of the parameter space to vectors in Hilbert space (quantum states) <span class="math notranslate nohighlight">\(\psi_W\)</span>.</p>
<p>The parameter space has a simple Euclidean metric, therefore the distance between two points <span class="math notranslate nohighlight">\(\bf{W}\)</span> and <span class="math notranslate nohighlight">\(\bf{W} + \bf{\delta W}\)</span> is simply  <span class="math notranslate nohighlight">\(\Vert\bf{\delta W} \Vert\)</span>.
However, what we really are interested in when optimizing variational ans√§tze is not the (Euclidean) distance between those two points in parameter space, but rather the distance in the Hilbert space between the corresponding quantum states (which also properly takes into account gauge degrees of freedom).
The quantum mechanical distance function for quantum states is the Fubini-Study distance <span class="math notranslate nohighlight">\( d(\psi, \phi) = \cos^{-1} \sqrt{\frac{\langle\psi|\phi\rangle \langle\phi|\psi\rangle}{\langle\psi|\psi\rangle \langle\phi|\phi\rangle}} \)</span>.
This can be expanded to second order in an infinitesimal parameter change <span class="math notranslate nohighlight">\(\delta W\)</span> as <span class="math notranslate nohighlight">\( d(\psi_W, \psi_{W + \delta W}) = (\delta W)^\dagger S \delta W \)</span> where <span class="math notranslate nohighlight">\( S \)</span> is the QGT.
In NetKet you can obtain (an approximation of) the quantum geometric tensor of a variational state by calling <a class="reference internal" href="_generated/variational/netket.vqs.VariationalState.html#netket.vqs.VariationalState.quantum_geometric_tensor" title="netket.vqs.VariationalState.quantum_geometric_tensor"><code class="xref py py-attr docutils literal notranslate"><span class="pre">quantum_geometric_tensor</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ma</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">RBM</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="n">sa</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">MetropolisLocal</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Spin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">n_chains</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">vs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">vqs</span><span class="o">.</span><span class="n">MCState</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

<span class="n">qgt</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">quantum_geometric_tensor</span><span class="p">()</span>
</pre></div>
</div>
<p>This will return an object that behaves as a Matrix, which acts on PyTrees of parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">grad</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">expect_and_grad</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">sigmax</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Spin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">qgt_times_grad</span> <span class="o">=</span> <span class="n">qgt</span><span class="nd">@grad</span>
</pre></div>
</div>
<p>The quantum geometric tensor also acts on dense ravellings of the parameters</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">grad_dense</span><span class="p">,</span> <span class="n">unravel</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">jax</span><span class="o">.</span><span class="n">tree_ravel</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
<span class="n">qgt_times_grad_dense</span> <span class="o">=</span> <span class="n">qgt</span><span class="nd">@grad_dense</span>
</pre></div>
</div>
<p>You can convert the quantum geometric tensor to a matrix representation by calling <code class="docutils literal notranslate"><span class="pre">qgt.to_dense()</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">qgt_dense</span> <span class="o">=</span> <span class="n">qgt</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
</pre></div>
</div>
<p>Lastly, you can solve the linear system <span class="math notranslate nohighlight">\( Q_{i,j} x_j = F_i \)</span> by calling the solve method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">qgt</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">gmres</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>
<span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">qgt</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">cholesky</span><span class="p">,</span> <span class="n">grad</span><span class="p">)</span>
</pre></div>
</div>
<p>While mathematically those operations are all well defined, there are several ways to implement them in code, all with different performance characteristics. For that reason, we have several (3) different implementations of the same Quantum Geometric Tensor object.
The 3 implemnentations are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="_generated/optim/netket.optimizer.qgt.QGTOnTheFly.html#netket-optimizer-qgt-qgtonthefly"><span class="std std-ref">netket.optimizer.qgt.QGTOnTheFly</span></a>, which uses jax automatic differentiation through two <code class="docutils literal notranslate"><span class="pre">vjp</span></code> and one <code class="docutils literal notranslate"><span class="pre">jvp</span></code> product to compute the action of quantum geometric tensor on a vector and operates natively on PyTrees. This method will essentially run AD every time you compute <code class="docutils literal notranslate"><span class="pre">QGT&#64;vector</span></code>. This method shines if the parameters of your network are stored in a PyTree with few leaf nodes and/or you are not performing many iterations of the iterative solver. It can compute the full dense QGT but it is not efficient at doing it so we advise not to use it with dense solvers.</p></li>
<li><p><a class="reference internal" href="_generated/optim/netket.optimizer.qgt.QGTJacobianDense.html#netket-optimizer-qgt-qgtjacobiandense"><span class="std std-ref">netket.optimizer.qgt.QGTJacobianDense</span></a>, which precomputes the log derivatives ( <span class="math notranslate nohighlight">\( O_k \)</span> ) when it‚Äôs constructed and converts it to a single dense array. If you have a high number of total parameters and/or many leaf nodes in your parameter PyTree, this implementation might perform better because everything is stored contiguously in memory. However, it has an high ‚Äòstartup cost‚Äô.</p></li>
<li><p><a class="reference internal" href="_generated/optim/netket.optimizer.qgt.QGTJacobianPyTree.html#netket-optimizer-qgt-qgtjacobianpytree"><span class="std std-ref">netket.optimizer.qgt.QGTJacobianPyTree</span></a>, same as above, but the precomputed jacobian is not stored contiguously in memory but is stored as a PyTree. This might work better than <code class="docutils literal notranslate"><span class="pre">QGTJacobianDense</span></code> if there are few leaf nodes. We haven‚Äôt studied the performance tradeoffs between the two Jacobian implementations and we would appreciate feedback.</p></li>
</ul>
<p>We also have an extra implementation, called <code class="docutils literal notranslate"><span class="pre">netket.optimizer.qgt.QGTAuto</span></code>, which uses some heuristics based on the parameters of the network to select the best QGT implementation. Be warned that the heuristics we use is very crude, and might not pick the best implementation all the time.</p>
<p>All the QGT implementations listed above have several options that can affect their performance.
We advise you to have a look at them and experiment.
We provide a lot of freedom because it‚Äôs not yet clear to us what is the best implementation for which kind of problems.
If you work with NetKet and determine that a particular implementation works best for certain types of networks, we would be glad to hear it! Let us know by opening a Discussion on our GitHub repository. We might use the insight to improve the automatic selection.</p>
<div class="section" id="stochastic-reconfiguration">
<h2>Stochastic Reconfiguration<a class="headerlink" href="#stochastic-reconfiguration" title="Permalink to this headline">ÔÉÅ</a></h2>
<p>The <a class="reference external" href="https://www.attaccalite.com/PhDThesis/html/node15.html">stochastic reconfiguration (SR) method</a> is a technique that makes use of the information encoded in the quantum geometric tensor described above to <em>precondition</em> the gradient used in stochastic optimization, <em>improving</em> the convergence rate to the ground state of a Hamiltonian <span class="math notranslate nohighlight">\( \hat{H} \)</span>.</p>
<p>We would like to underline that SR can be derived (and therefore thought of) as imaginary time evolution of the variational ansatz.
The derivation in the case of a variational optimization for the ground state, can be sketched as follows:</p>
<p>Given a a variational wavefunction <span class="math notranslate nohighlight">\( \ket{\psi_W} \)</span>, we consider its first order Taylor expansion around <span class="math notranslate nohighlight">\( W \)</span>, <span class="math notranslate nohighlight">\( \ket{\psi_{W+\delta W}} = \ket{\psi_W} + \delta W_k \hat{O}_k \ket{\psi_W} \)</span>, where <span class="math notranslate nohighlight">\( \bra{\sigma}\hat{O}_k \ket{\eta} = \delta_{\sigma,\eta} \frac{d \log\psi_W(\sigma)}{dW_k}\)</span>.
We wish to determine the updates <span class="math notranslate nohighlight">\( \delta_{\sigma,\eta} \)</span> of the variational parameters that match a step of imaginary-time evolution, given by</p>
<div class="amsmath math notranslate nohighlight" id="equation-8acf2fed-a705-46da-8a65-15c4980b9eb6">
<span class="eqno">(1)<a class="headerlink" href="#equation-8acf2fed-a705-46da-8a65-15c4980b9eb6" title="Permalink to this equation">ÔÉÅ</a></span>\[\begin{equation}
\ket{\phi} = U(\epsilon)\ket{\psi_W} = e^{\epsilon\hat{H}}\ket{\psi_W} \sim (\mathbb{I} - \epsilon \hat{H})\ket{\psi_W}
\end{equation}\]</div>
<p>It is possible to show that the updates <span class="math notranslate nohighlight">\(\delta W_k \)</span> that minimise the norm of the state <span class="math notranslate nohighlight">\(\ket{\phi}-\ket{\psi_{W+\delta W}}\)</span> can be determined by solving the linear system</p>
<div class="amsmath math notranslate nohighlight" id="equation-b2e4aadb-886d-4134-b338-d84169655ce3">
<span class="eqno">(2)<a class="headerlink" href="#equation-b2e4aadb-886d-4134-b338-d84169655ce3" title="Permalink to this equation">ÔÉÅ</a></span>\[\begin{equation}
S_{i,k} \delta W_k = F_i
\end{equation}\]</div>
<p>where <span class="math notranslate nohighlight">\( F_i = \langle \hat{E}^{loc} \hat{O}_i\rangle_c \)</span> is the gradient of the Energy and <span class="math notranslate nohighlight">\( S_{i,k} = \langle \hat{O}^\dagger_i \hat{O}_k\rangle_c \)</span> is the Quantum Geometric Tensor.
The QGT is positive definite, therefore it can be inverted and the solution is formally written as</p>
<div class="amsmath math notranslate nohighlight" id="equation-6e28526d-7860-4a12-b954-a3bffd8991bd">
<span class="eqno">(3)<a class="headerlink" href="#equation-6e28526d-7860-4a12-b954-a3bffd8991bd" title="Permalink to this equation">ÔÉÅ</a></span>\[\begin{equation}
\bf{\delta W} = S^{-1} \bf{F},
\end{equation}\]</div>
<p>where bold fonts are used for vectors.
A complication is given by the fact that the QGT is determined by Monte Carlo sampling and it might have several eigenvalues that are zero or very small, leading to numerical stability issues when inverting the matrix or in the resulting dynamics.
The linear system can be solved with several methods. For the models with many parameters and to achieve the best performance, iterative solvers such as those found in <code class="docutils literal notranslate"><span class="pre">jax.scipy.sparse.linalg</span></code>, such as <span class="xref std std-ref">jax.scipy.sparse.linalg.cg</span> <span class="xref std std-ref">jax.scipy.sparse.linalg.gmres</span> are the best choice.
Do note that to stabilize those algorithms it is often needed to add a small (<span class="math notranslate nohighlight">\(10^{-5} - 10^{-2}\)</span>) shift to the diagonal of the QGT.
This can be set with the keyword argument <code class="docutils literal notranslate"><span class="pre">diag_shift</span></code>.
Those methods, combined with our lazy representations of the QGT, never instantiate the full matrix and therefore achieve a great performance.
However, when the number of parameters is small (smaller than 1000-5000), it might make sense to solve the system by factorizing the QGT with cholesky or SVD.
Those techniques require instantiating the full dense matrix, but in general are more stable and don‚Äôt require a diagonal shift.</p>
<div class="section" id="using-stochastic-reconfiguration">
<h3>Using stochastic reconfiguration<a class="headerlink" href="#using-stochastic-reconfiguration" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>To use SR, you must simply provide it as a preconditioner to the VMC solver.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sr</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">SR</span><span class="p">()</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">VMC</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">variational_state</span><span class="o">=</span><span class="n">vstate</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>By default this will use an appropriate QGT and the iterative solver <code class="docutils literal notranslate"><span class="pre">jax.scipy.sparse.linalg.cg</span></code>.
It is possible to change the iterative solver by providing any solver from <code class="docutils literal notranslate"><span class="pre">jax.scipy.sparse.linalg</span></code> or one of the dense solvers in <code class="docutils literal notranslate"><span class="pre">netket.optimizer.solver</span></code> (such as svd/cholesky/LU) to the SR object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sr</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">SR</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">cholesky</span><span class="p">)</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">VMC</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">variational_state</span><span class="o">=</span><span class="n">vstate</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>The solver should be a function that accepts two arguments: the S matrix and the F vector in the linear system to be solved, and an optional x0 keyword argument.
If you want to specify options of a linear solver, such as the tolerance or the cutoff rate you can do the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">sr</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">SR</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">gmres</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">))</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">VMC</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">variational_state</span><span class="o">=</span><span class="n">vstate</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>

</pre></div>
</div>
<p>If you don‚Äôt specify the QGT format, NetKet will try to guess the best format.
We reccomend you experiment and specify the QGT format that gives you the best performance, which can be by passing it as an argument. Additional keyword arguments will be forwarded to the QGT constructor, as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sr</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">SR</span><span class="p">(</span><span class="n">QGTJacobianPyTree</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">gmres</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span><span class="n">diag_shift</span><span class="o">=</span><span class="mf">1e-3</span>
<span class="n">gs</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">VMC</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">variational_state</span><span class="o">=</span><span class="n">vstate</span><span class="p">,</span> <span class="n">preconditioner</span><span class="o">=</span><span class="n">sr</span><span class="p">)</span>
</pre></div>
</div>
<p>Since SR leads to an optimisation that approximates an imaginary time evolution, we find that in general it is not a good idea to couple SR with advanced optimisers like ADAM, which modify the gradient remarkably. Stochastic Gradient Descent is the best choice in general.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="varstate.html" class="btn btn-neutral float-left" title="The Variational State Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="drivers.html" class="btn btn-neutral float-right" title="The Drivers API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, The Netket authors - All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 

<script type="text/javascript">
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
      })
</script>

<!-- Temporary footer
<div class="footer-wip">
  <div class="footer-wip-content">
    This documentation refers to an unreleased version of Netket.
  </div>
</div>
-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118013987-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-118013987-1');
</script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "url": "https://www.netket.org",
  "name": "NetKet",
  "founder": "Giuseppe Carleo",
  "foundingDate": "2018-04-24",
  "foundingLocation" : "New York",
  "logo": "https://www.netket.org/img/logo_small.jpg",
  "sameAs": [
    "https://twitter.com/NetKetOrg",
    "https://github.com/NetKet/netket"
  ],
  "description" : "Netket is an open-source project delivering cutting-edge
  methods for the study of many-body quantum systems with artificial neural
  networks and machine learning techniques."
}
</script>


</body>
</html>