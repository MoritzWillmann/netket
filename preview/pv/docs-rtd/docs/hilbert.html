<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Hilbert module &mdash; netket v3.0 documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "tex2jax_ignore|mathjax_ignore|document", "processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The Operator module" href="operator.html" />
    <link rel="prev" title="The Lindblad Master Equation" href="superop.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> netket<img src="../_static/logonav.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/netket3.html">Ground-State Variational Search with NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/jax.html">Using JAX as a backend in NetKet - Feature Preview for v3.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/G-CNN_Honeycomb.html">Using a group convolutional neural network to learn the ground-state of a symmetric spin model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/j1j2.html">Variational Monte Carlo with Neural Networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/Heisenberg1d.html">Learning the ground-state of a spin model with different Neural Networks available in NetKet</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="superop.html">The Lindblad Master Equation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Hilbert module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-abstracthilbert-interface">The <code class="docutils literal notranslate"><span class="pre">AbstractHilbert</span></code> interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#attributes">Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composing-hilbert-spaces">Composing Hilbert spaces</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-discretehilbert-interface">The <code class="docutils literal notranslate"><span class="pre">DiscreteHilbert</span></code> interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#indexable-spaces">Indexable spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constrained-hilbert-spaces">Constrained Hilbert spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-custom-constraints">Defining Custom constraints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-hilbert-spaces-with-jax-jitted-functions">Using Hilbert spaces with <span class="xref std std-ref">jax.jit</span>ted functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="operator.html">The Operator module</a></li>
<li class="toctree-l1"><a class="reference internal" href="varstate.html">The Variational State Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="sr.html">Quantum Geometric Tensor and Stochastic Reconfiguration</a></li>
<li class="toctree-l1"><a class="reference internal" href="drivers.html">The Drivers API</a></li>
<li class="toctree-l1"><a class="reference internal" href="sharp-bits.html">üî™ The Sharp Bits üî™</a></li>
</ul>
<p class="caption"><span class="caption-text">Extending NetKet</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="custom_models.html">Defining Custom Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_expect.html">Overriding defaults in NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_preconditioners.html">Defining Custom Preconditioners</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_operator.html">Defining Custom Operators</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to NetKet</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing-tests.html">Writing Tests</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-stability.html">API Stability</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Public API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-experimental.html">Experimental API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">netket</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>The Hilbert module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/docs/hilbert.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="the-hilbert-module">
<span id="hilbert"></span><h1>The Hilbert module<a class="headerlink" href="#the-hilbert-module" title="Permalink to this headline">ÔÉÅ</a></h1>
<p>The <span class="xref myst">Hilbert</span> module defines the abstract Hilbert space API and some concrete implementations, such as <a class="reference internal" href="_generated/hilbert/netket.hilbert.Spin.html#netket-hilbert-spin"><span class="std std-ref">netket.hilbert.Spin</span></a>, <a class="reference internal" href="_generated/hilbert/netket.hilbert.Fock.html#netket-hilbert-fock"><span class="std std-ref">netket.hilbert.Fock</span></a>.
An <code class="docutils literal notranslate"><span class="pre">Hilbert</span></code> object represents a Hilbert space together with a particular choice of computational basis.
They are needed to construct most other objects in NetKet, but they can also be useful to experiment and validate variational ans√§tze.</p>
<p>Hilbert space objects are all sub-classes of the abstract class <a class="reference internal" href="_generated/hilbert/netket.hilbert.AbstractHilbert.html#netket-hilbert-abstracthilbert"><span class="std std-ref">netket.hilbert.AbstractHilbert</span></a>, which defines the general API respected by all implementations.
You can see a birds-eye view of the inheritance diagram among the various kinds of Hilbert spaces included with NetKet below (you can click on the nodes in the graph to go to their API documentation page).
Classes whose edge is dashed are abstract classes, while the others are concrete and can be instantiated.</p>
<div class="graphviz"><img src="../_images/inheritance-b88b4f6594e4326f6827786377243c6c4df547ba.png" alt="Inheritance diagram of netket.hilbert" usemap="#inheritancea41024210a" class="inheritance graphviz" /></div>
<map id="inheritancea41024210a" name="inheritancea41024210a">
<area shape="rect" id="node1" href="_generated/hilbert/netket.hilbert.AbstractHilbert.html#netket.hilbert.AbstractHilbert" target="_top" title="Abstract class for NetKet hilbert objects." alt="" coords="5,80,125,105"/>
<area shape="rect" id="node2" href="_generated/hilbert/netket.hilbert.ContinuousHilbert.html#netket.hilbert.ContinuousHilbert" target="_top" title="Abstract class for the Hilbert space of particles" alt="" coords="173,43,312,68"/>
<area shape="rect" id="node5" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert" target="_top" title="Abstract class for an hilbert space defined on a lattice." alt="" coords="183,104,303,129"/>
<area shape="rect" id="node8" href="_generated/hilbert/netket.hilbert.Particle.html#netket.hilbert.Particle" target="_top" title="Hilbert space derived from AbstractParticle for" alt="" coords="404,29,476,55"/>
<area shape="rect" id="node3" href="_generated/hilbert/netket.hilbert.CustomHilbert.html#netket.hilbert.CustomHilbert" target="_top" title="A custom hilbert space with discrete local quantum numbers." alt="" coords="568,5,684,31"/>
<area shape="rect" id="node4" href="_generated/hilbert/netket.hilbert.HomogeneousHilbert.html#netket.hilbert.HomogeneousHilbert" target="_top" title="The Abstract base class for homogeneous hilbert spaces." alt="" coords="360,79,520,104"/>
<area shape="rect" id="node7" href="_generated/hilbert/netket.hilbert.Fock.html#netket.hilbert.Fock" target="_top" title="Hilbert space obtained as tensor product of local fock basis." alt="" coords="590,55,662,80"/>
<area shape="rect" id="node9" href="_generated/hilbert/netket.hilbert.Qubit.html#netket.hilbert.Qubit" target="_top" title="Hilbert space obtained as tensor product of local qubit states." alt="" coords="590,104,662,129"/>
<area shape="rect" id="node10" href="_generated/hilbert/netket.hilbert.Spin.html#netket.hilbert.Spin" target="_top" title="Hilbert space obtained as tensor product of local spin states." alt="" coords="590,153,662,179"/>
<area shape="rect" id="node11" href="_generated/hilbert/netket.hilbert.TensorHilbert.html#netket.hilbert.TensorHilbert" target="_top" title="Tensor product of several Discrete sub&#45;spaces, representing the space" alt="" coords="386,177,494,203"/>
</map><p><a class="reference internal" href="_generated/hilbert/netket.hilbert.AbstractHilbert.html#netket-hilbert-abstracthilbert"><span class="std std-ref">netket.hilbert.AbstractHilbert</span></a> makes very few assumptions on the structure of the resulting space and you will generally very rarely interact with it directly.
Derived from <code class="docutils literal notranslate"><span class="pre">AbstractHilbert</span></code> are two less generic, but still abstract, types: <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket-hilbert-discretehilbert"><span class="std std-ref">netket.hilbert.DiscreteHilbert</span></a>, representing Hilbert spaces where the local degrees of freedom are countable, and <a class="reference internal" href="_generated/hilbert/netket.hilbert.ContinuousHilbert.html#netket-hilbert-continuoushilbert"><span class="std std-ref">netket.hilbert.ContinuousHilbert</span></a>, representing the Hilbert spaces with continuous bases, such as particles in a box.</p>
<p>So far, the majority of NetKet development has focused <code class="docutils literal notranslate"><span class="pre">DiscreteHilbert</span></code> spaces which therefore have a much more developed API, while <code class="docutils literal notranslate"><span class="pre">ContinuousHilbert</span></code> is still experimental and does not yet support many operations.</p>
<p>The most important class of discrete Hilbert spaces are subclasses of <a class="reference internal" href="_generated/hilbert/netket.hilbert.HomogeneousHilbert.html#netket-hilbert-homogeneoushilbert"><span class="std std-ref">netket.hilbert.HomogeneousHilbert</span></a>, which is a tensor product of a finite number of local Hilbert spaces of the same kind, each with the same number of local degrees of freedom.
<code class="docutils literal notranslate"><span class="pre">HomogeneousHilbert</span></code> has the concrete subclasses <a class="reference internal" href="_generated/hilbert/netket.hilbert.Fock.html#netket-hilbert-fock"><span class="std std-ref">netket.hilbert.Fock</span></a>, <a class="reference internal" href="_generated/hilbert/netket.hilbert.Spin.html#netket-hilbert-spin"><span class="std std-ref">netket.hilbert.Spin</span></a>, and <a class="reference internal" href="_generated/hilbert/netket.hilbert.Qubit.html#netket-hilbert-qubit"><span class="std std-ref">netket.hilbert.Qubit</span></a>.</p>
<p><a class="reference internal" href="_generated/hilbert/netket.hilbert.TensorHilbert.html#netket-hilbert-tensorhilbert"><span class="std std-ref">netket.hilbert.TensorHilbert</span></a> represents tensor products of different homogeneous hilbert spaces, therefore it is not homogeneous. You can use it to represent composite systems such as spin-boson setups.</p>
<p><a class="reference internal" href="_generated/hilbert/netket.hilbert.DoubledHilbert.html#netket-hilbert-doubledhilbert"><span class="std std-ref">netket.hilbert.DoubledHilbert</span></a> represents a space doubled through <a class="reference external" href="https://en.wikipedia.org/wiki/Choi%E2%80%93Jamio%C5%82kowski_isomorphism">Choi‚Äôs Isomorphism</a>.
This is the space of density matrices and is used to work with dissipative/open systems.</p>
<div class="section" id="the-abstracthilbert-interface">
<h2>The <code class="docutils literal notranslate"><span class="pre">AbstractHilbert</span></code> interface<a class="headerlink" href="#the-abstracthilbert-interface" title="Permalink to this headline">ÔÉÅ</a></h2>
<p>As we mentioned before, an Hilbert object represents at the same time a choice of Hilbert space and computational basis.
The reason why we need to specify a computational basis is that with Variational methods we often have to perform summations (or sample) the hilbert space. For example, we often write the wavefunction as</p>
<div class="math notranslate nohighlight">
\[
|\psi\rangle = \sum_{\bf{\sigma}\in\mathcal{H}} \psi(\sigma) |\bf{\sigma}\rangle
\]</div>
<p>The choice of computational basis affects the values that those <span class="math notranslate nohighlight">\(\bf{\sigma} = |\sigma_0, \sigma_1, \sigma_2, \dots, \sigma_N\rangle \)</span> will take
To give an example: when working with Qubits we often take as the basis the <span class="math notranslate nohighlight">\(\hat{Z}\)</span> basis, where <span class="math notranslate nohighlight">\(\sigma_i=\{0,1\}\)</span>, but we could have also chosen the <span class="math notranslate nohighlight">\(\hat{Y}\)</span> or <span class="math notranslate nohighlight">\(\hat{X}\)</span> basis, where operators would have different basis elements.</p>
<p>Currently, all the operators shipping with NetKet hardcode the choice of <span class="math notranslate nohighlight">\(\hat{Z}\)</span> (or number-basis in Fock space) as the computational basis, but eventually we might relax this constraint.</p>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>All Hilbert spaces expose one attribute: <a class="reference internal" href="_generated/hilbert/netket.hilbert.AbstractHilbert.html#netket.hilbert.AbstractHilbert.size" title="netket.hilbert.AbstractHilbert.size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>
This is an integer that exposes how many degrees of freedom has the basis of the Hilbert space.
For discrete spaces, this corresponds exactly to the number of sites (which is, e.g., the number of spins in a <code class="docutils literal notranslate"><span class="pre">Spin</span></code> Hilbert space).
Therefore, elements of the basis of an <span class="math notranslate nohighlight">\(N\)</span> spin-<span class="math notranslate nohighlight">\(1/2\)</span> system are vectors in <span class="math notranslate nohighlight">\(\{-1,+1\}^N\)</span>, an <span class="math notranslate nohighlight">\(N-\)</span> dimensional space.</p>
<p>As NetKet is a package focused on Monte Carlo calculations, we also need a way to generate random configurations distributed uniformly from the basis of an Hilbert space.
This can be achieved through the method <a class="reference internal" href="#netket.hilbert.AbstractHilbert.random_state" title="netket.hilbert.AbstractHilbert.random_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_state()</span></code></a>.</p>
<dl class="py method">
<dt id="netket.hilbert.AbstractHilbert.random_state">
<code class="sig-prename descclassname"><span class="pre">AbstractHilbert.</span></code><code class="sig-name descname"><span class="pre">random_state</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">key=None</span></em>, <em class="sig-param"><span class="pre">size=None</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/netket/hilbert/abstract_hilbert.html#AbstractHilbert.random_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#netket.hilbert.AbstractHilbert.random_state" title="Permalink to this definition">ÔÉÅ</a></dt>
<dd><p>Generates either a single or a batch of uniformly distributed random states.
Runs as <code class="code docutils literal notranslate"><span class="pre">random_state(self,</span> <span class="pre">key,</span> <span class="pre">size=None,</span> <span class="pre">dtype=np.float32)</span></code> by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> ‚Äì rng state from a jax-style functional generator.</p></li>
<li><p><strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Optional" title="(in Python v3.10)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code></a>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>]) ‚Äì If provided, returns a batch of configurations of the form
<code class="code docutils literal notranslate"><span class="pre">(size,</span> <span class="pre">N)</span></code> if size is an integer or <code class="code docutils literal notranslate"><span class="pre">(*size,</span> <span class="pre">N)</span></code> if it is
a tuple and where <span class="math notranslate nohighlight">\(N\)</span> is the Hilbert space size.
By default, a single random configuration with shape
<code class="code docutils literal notranslate"><span class="pre">(#,)</span></code> is returned.</p></li>
<li><p><strong>dtype</strong> ‚Äì DType of the resulting vector.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.html#jax.numpy.ndarray" title="(in JAX)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A state or batch of states sampled from the uniform distribution on the
hilbert space.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netket</span><span class="o">,</span> <span class="nn">jax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">netket</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Qubit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hi</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">k1</span><span class="p">))</span>
<span class="go">[1. 0.]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hi</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">k2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[0. 0.]</span>
<span class="go"> [0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">random_state</span></code> behaves similarly to <span class="xref std std-ref">jax.random.uniform</span>: the first argument is a Jax PRNGKey, the second is the shape or number of resulting elements and the third is the dtype of the output (which defaults to <code class="docutils literal notranslate"><span class="pre">jnp.float32</span></code>, or single precision.
The resulting basis elements will be distributed uniformly.</p>
<div class="admonition-jax-prng admonition">
<p class="admonition-title">Jax PRNG</p>
<p>If you are not familiar with Jax random number generators: Jax PRNGKey is the state of the Pseudo-random number generator, that determines what will be the next random numbers generated. To learn more about it, refer to <a class="reference external" href="https://jax.readthedocs.io/en/latest/jax.random.html">this documentation</a>).</p>
</div>
</div>
<div class="section" id="composing-hilbert-spaces">
<h3>Composing Hilbert spaces<a class="headerlink" href="#composing-hilbert-spaces" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>Hilbert spaces can be composed together.
The syntax to do that is Python‚Äôs multiplication operator, <code class="docutils literal notranslate"><span class="pre">*</span></code>, which will be interpreted as a Kronecker product, or tensor product, of those Hilbert spaces, in the specified order.</p>
<p>It is also possible to take Kronecker powers of an Hilbert space with the exponent operator <code class="docutils literal notranslate"><span class="pre">**</span></code> using an integer exponent. This will be interpreted as repeating the Kronecker product N times.</p>
<p>At times, when trying to compose Hilbert spaces, you might hit a <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.
This means that the composition of those two spaces has not yet been implemented by anyone.
Please do open an issue or a feature request on the GitHub repository if you encounter this error.</p>
</div>
</div>
<div class="section" id="the-discretehilbert-interface">
<h2>The <code class="docutils literal notranslate"><span class="pre">DiscreteHilbert</span></code> interface<a class="headerlink" href="#the-discretehilbert-interface" title="Permalink to this headline">ÔÉÅ</a></h2>
<p><a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket-hilbert-discretehilbert"><span class="std std-ref">netket.hilbert.DiscreteHilbert</span></a> is also an abstract class from which any hilbert space with countable (or discrete) local degrees of freedom must inherit.
Examples of such spaces are spins or bosons on a lattice.</p>
<p>You can always probe their <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.shape" title="netket.hilbert.DiscreteHilbert.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a>, which returns a tuple
with the size of the hilbert space on every site/degree of freedom.
For example, for 4 spins-<span class="math notranslate nohighlight">\(1/2\)</span> coupled to a bosonic mode with a cutoff of 5 bosons, the shape will be
<code class="docutils literal notranslate"><span class="pre">[2,2,2,2,6]</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">netket.hilbert</span> <span class="kn">import</span> <span class="n">Spin</span><span class="p">,</span> <span class="n">Fock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">Spin</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">Fock</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">shape</span>
<span class="go">array([2, 2, 2, 2, 6])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">shape</span></code> is also linked to the local Hilbert basis, which lists all possible values that a basis elements can take on this particular lattice site/subsystem.
For example, on the first four sites of the example above, the basis elements are only 2: <code class="docutils literal notranslate"><span class="pre">[-1,</span> <span class="pre">1]</span></code>, while on the last site they are 6: <code class="docutils literal notranslate"><span class="pre">[0,1,2,3,4,5]</span></code>.</p>
<p>This information can be extracted with the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.states_at_index" title="netket.hilbert.DiscreteHilbert.states_at_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">states_at_index()</span></code></a> method, as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_at_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[-1.0, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_at_index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[-1.0, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_at_index</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4, 5]</span>
</pre></div>
</div>
<p>It should be now evident why NetKet distinguishes locally discrete/countable spaces from arbitrary (e.g: continuous) spaces: if we can index the local basis, we can perform many optimisations and write efficient kernels to compute matrix elements of operators, but also Monte-Carlo samplers will propose transitions in a very different way than in continuous spaces.</p>
<p>You can also obtain the total size of the hilbert space by invoking <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.n_states" title="netket.hilbert.DiscreteHilbert.n_states"><code class="xref py py-attr docutils literal notranslate"><span class="pre">n_states</span></code></a>, which in general is equivalent to calling <code class="docutils literal notranslate"><span class="pre">np.prod(hi.shape)</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">n_states</span>
<span class="go">96</span>
</pre></div>
</div>
<p>Do bear in mind that this attribute only works if the hilbert space is indexable (<a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.is_indexable" title="netket.hilbert.DiscreteHilbert.is_indexable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_indexable</span></code></a>), which is True when it has a size smaller than <span class="math notranslate nohighlight">\( 2^{64} \)</span>.</p>
<p>NetKet also supports discrete-but-infinite hilbert spaces, such as Fock spaces with no cutoff.
Those hilbert spaces are of course not indexable (<a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.is_indexable" title="netket.hilbert.DiscreteHilbert.is_indexable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_indexable</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">False</span></code>) and they are further signaled by the attribute (<a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.is_finite" title="netket.hilbert.DiscreteHilbert.is_finite"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_finite</span></code></a>, which will be set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The only non-finite (discrete) hilbert space implemented in NetKet is the Fock space, and it can be constructed by not specifying the cutoff, as shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Fock</span><span class="p">()</span> <span class="c1"># 1 mode with no cutoff</span>
<span class="go">Fock(n_max=INT_MAX, N=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Fock</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># 3 modes with no cutoff</span>
<span class="go">Fock(n_max=INT_MAX, N=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Fock</span><span class="p">()</span><span class="o">**</span><span class="mi">3</span>  <span class="c1"># 3 modes with no cutoff, alternative syntax</span>
<span class="go">Fock(n_max=INT_MAX, N=3)</span>
</pre></div>
</div>
<p>Do bear in mind that due to computational limitations, <em>infinite</em> Hilbert spaces are not technically infinite, but simply have their cutoff set to <span class="math notranslate nohighlight">\( 2^{63} \)</span>, the largest signed integer.</p>
<div class="section" id="indexable-spaces">
<h3>Indexable spaces<a class="headerlink" href="#indexable-spaces" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>If a space is indexable it is possible to perform several handy operations on it, especially useful when you are checking the correctness of your calculations.
In practice all those operations rely on converting elements of the basis such as <code class="docutils literal notranslate"><span class="pre">[0,1,1,0]</span></code> to an integer index labelling all basis elements.</p>
<p>For the following examples, we will be using the <a class="reference internal" href="_generated/hilbert/netket.hilbert.Qubit.html#netket-hilbert-qubit"><span class="std std-ref">netket.hilbert.Qubit</span></a> hilbert space, whose local basis is <code class="docutils literal notranslate"><span class="pre">[0,1]</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">netket</span> <span class="k">as</span> <span class="nn">nk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Qubit(N=3)</span>
</pre></div>
</div>
<p>Converting indices to basis elements can be performed through the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.numbers_to_states" title="netket.hilbert.DiscreteHilbert.numbers_to_states"><code class="xref py py-meth docutils literal notranslate"><span class="pre">numbers_to_states()</span></code></a> method.
When converting indices to a basis-element, NetKet relies on a sort of big-endian (or Most-Significant-Bit first) N-ary-encoding: for qubits, index <span class="math notranslate nohighlight">\(0\)</span> will correspond to <span class="math notranslate nohighlight">\(|0,0,0\rangle\)</span>, index <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(|0,0,1\rangle\)</span>, index <span class="math notranslate nohighlight">\(2\)</span> to <span class="math notranslate nohighlight">\(|0,1,0\rangle\)</span> and so on.
For hilbert spaces with larger local dimensions, all the local states are iterated continuously.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">numbers_to_states</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0., 0., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">numbers_to_states</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0., 0., 1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">numbers_to_states</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([0., 1., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">numbers_to_states</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([0., 1., 1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">numbers_to_states</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">array([1., 1., 1.])</span>
</pre></div>
</div>
<p>It is also possible to perform the opposite transformation and go from a basis element to an integer index using the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.states_to_numbers" title="netket.hilbert.DiscreteHilbert.states_to_numbers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">states_to_numbers()</span></code></a> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_to_numbers</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_to_numbers</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">states_to_numbers</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Do notice that all those methods work with arrays too and will convert an array of <span class="math notranslate nohighlight">\(M\)</span> indices to a batch of states, that is, a matrix of size <span class="math notranslate nohighlight">\(M \times N\)</span>.</p>
<p>Lastly, it is also possible to obtain the batch of all basis states with the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.all_states" title="netket.hilbert.DiscreteHilbert.all_states"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all_states()</span></code></a> method.</p>
</div>
<div class="section" id="constrained-hilbert-spaces">
<h3>Constrained Hilbert spaces<a class="headerlink" href="#constrained-hilbert-spaces" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>The Hilbert spaces provided by NetKet are compatible with some simple constraints.
The constraints that can be imposed are quite ~constrained~ limited themselves: they can only act on the set of basis elements, for example by excluding those that do not satisfy a certain condition.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Warning: Common error
When you define a constrained Hilbert space and you use it with a Markov-Chain sampler, the constraints guarantees that the initial state of the chain, generated through the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.random_state" title="netket.hilbert.DiscreteHilbert.random_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_state()</span></code></a> method, respects the constraint.</p>
<p>However, <em>it is not guaranteed that a transition rule will respect the constraint.</em>
In fact, built-in samplers are not aware of the constraints directly, even though some of can still be used effectively with constraints.</p>
<p>A typical error is to use <a class="reference internal" href="_generated/samplers/netket.sampler.MetropolisLocal.html#netket.sampler.MetropolisLocal" title="netket.sampler.MetropolisLocal"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetropolisLocal</span></code></a> with a constrained Hilbert space, such as a Fock space with a fixed number of particles.
A simple workaround is to use <a class="reference internal" href="_generated/samplers/netket.sampler.MetropolisExchange.html#netket.sampler.MetropolisExchange" title="netket.sampler.MetropolisExchange"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetropolisExchange</span></code></a>: as it exchanges the value on two different sites, it guarantees that the total number
of particles is conserved, and therefore respects the constraint if it is correctly imposed at the initialization of the chain.</p>
<p>In short: when working with constrained Hilbert spaces you have to take extra care when chosing your sampler. And if you have exotic constraints you will most likely need to define your own transition kernel. But don‚Äôt worry: it is very easy! (however nobody has yet written documentation for it. In the meantime, have a look at <a class="reference external" href="https://github.com/netket/netket/discussions/755#discussioncomment-858719">this discussion</a>)</p>
</div>
<p>The constraints supported on the built-in hilbert spaces are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="_generated/hilbert/netket.hilbert.Spin.html#netket.hilbert.Spin" title="netket.hilbert.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a> supports an optional keyword argument <code class="docutils literal notranslate"><span class="pre">total_sz</span></code> which can be used to impose a fixed total magnetization.
The total magnetization of a basis element is defined as <span class="math notranslate nohighlight">\(\sum_i \sigma_i\)</span>. Be aware that this constraint is efficiently
imposed when calling <code class="docutils literal notranslate"><span class="pre">random_state</span></code> only for spins-<span class="math notranslate nohighlight">\( S=1/2 \)</span>, while for larger values of <span class="math notranslate nohighlight">\( S \)</span> it is not efficient. This
should not be a problem as long as you use this method just to initialise your markov chains.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Spin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">total_sz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span>
<span class="go">array([[-1., -1.,  1.,  1.],</span>
<span class="go">       [-1.,  1., -1.,  1.],</span>
<span class="go">       [-1.,  1.,  1., -1.],</span>
<span class="go">       [ 1., -1., -1.,  1.],</span>
<span class="go">       [ 1., -1.,  1., -1.],</span>
<span class="go">       [ 1.,  1., -1., -1.]])</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="_generated/hilbert/netket.hilbert.Fock.html#netket.hilbert.Fock" title="netket.hilbert.Fock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fock</span></code></a> supports an optional keyword argument <code class="docutils literal notranslate"><span class="pre">n_particles</span></code> which can be used to impose a fixed total number of particles.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">Fock</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_particles</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span>
<span class="go">array([[0., 2.],</span>
<span class="go">       [1., 1.],</span>
<span class="go">       [2., 0.]])</span>
</pre></div>
</div>
<ul class="simple">
<li><p>It is also possible to define a custom (Homogeneous) hilbert space with a custom constraint. To see how to do that, check the section‚Ä¶</p></li>
</ul>
</div>
<div class="section" id="defining-custom-constraints">
<h3>Defining Custom constraints<a class="headerlink" href="#defining-custom-constraints" title="Permalink to this headline">ÔÉÅ</a></h3>
<p>NetKet provides a custom class <code class="docutils literal notranslate"><span class="pre">CustomHilbert</span></code>, that makes it relatively simple to define your own constaint on homogeneous Hilbert spaces.
In this example we show how to use it to build a space that behaves like <span class="xref std std-ref">Fock</span>, while enforcing even parity.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numba</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">accept_even</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>	<span class="k">return</span> <span class="n">states</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n_max</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">N_sites</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">netket</span><span class="o">.</span><span class="n">hilbert</span><span class="o">.</span><span class="n">CustomHilbert</span><span class="p">(</span><span class="n">local_states</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">n_max</span><span class="p">),</span> <span class="n">N</span><span class="o">=</span><span class="n">N_sites</span><span class="p">,</span> <span class="n">constraint_fn</span><span class="o">=</span><span class="n">accept_even</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0., 2.],</span>
<span class="go">       [0., 0., 0., 1., 1.],</span>
<span class="go">       [0., 0., 0., 2., 0.],</span>
<span class="go">       ...</span>
</pre></div>
</div>
<p>The constraint function sums the basis number (a number in <code class="docutils literal notranslate"><span class="pre">range(n_max)</span></code>) and then checks if it is even.
Pleaes notice how we used <code class="docutils literal notranslate"><span class="pre">&#64;numba.njit</span></code> to speed up the constraint.</p>
<p>If you then want to sample this space, you‚Äôll encounter the following error:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">jax</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;.../netket/hilbert/abstract_hilbert.py&quot;</span>, line <span class="m">84</span>, in <span class="n">random_state</span>
    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  File <span class="nb">&quot;plum/function.py&quot;</span>, line <span class="m">537</span>, in <span class="n">plum.function.Function.__call__</span>
  File <span class="nb">&quot;.../netket/hilbert/random/custom.py&quot;</span>, line <span class="m">25</span>, in <span class="n">random_state</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
<span class="gr">NotImplementedError</span>
</pre></div>
</div>
<p>This is because you did not specify how to sample the space. To do so, check the documentation on defining custom Hilbert spaces.</p>
</div>
</div>
<div class="section" id="using-hilbert-spaces-with-jax-jitted-functions">
<h2>Using Hilbert spaces with <span class="xref std std-ref">jax.jit</span>ted functions<a class="headerlink" href="#using-hilbert-spaces-with-jax-jitted-functions" title="Permalink to this headline">ÔÉÅ</a></h2>
<p>Hilbert spaces are immutable, hashable objects.
Their hash is computed by hashing their inner fields, determined by the internal <code class="xref py py-meth docutils literal notranslate"><span class="pre">_attrs()</span></code> method.
You can freely use <code class="docutils literal notranslate"><span class="pre">AbstractHilbert</span></code> objects inside of <code class="docutils literal notranslate"><span class="pre">jax.jit</span></code>ted functions as long as you specify that they are <code class="docutils literal notranslate"><span class="pre">static</span></code>.</p>
<p>All attributes and methods of Hilbert spaces can be freely used inside of a <code class="docutils literal notranslate"><span class="pre">jax.jit</span></code> block except for
<a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.states_to_numbers" title="netket.hilbert.DiscreteHilbert.states_to_numbers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">states_to_numbers()</span></code></a> and <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.numbers_to_states" title="netket.hilbert.DiscreteHilbert.numbers_to_states"><code class="xref py py-meth docutils literal notranslate"><span class="pre">numbers_to_states()</span></code></a>, because
they are written using <span class="xref std std-ref">numpy</span> instead of jax.</p>
<p>In particular the <a class="reference internal" href="_generated/hilbert/netket.hilbert.DiscreteHilbert.html#netket.hilbert.DiscreteHilbert.random_state" title="netket.hilbert.DiscreteHilbert.random_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">random_state()</span></code></a> method can be used inside of jitted blocks, as it is written in jax, as long as you pass a valid jax
<span class="xref std std-ref">jax.random.PRNGKey</span> object as the first argument.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="superop.html" class="btn btn-neutral float-left" title="The Lindblad Master Equation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="operator.html" class="btn btn-neutral float-right" title="The Operator module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2021, The Netket authors - All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 

<script type="text/javascript">
    jQuery(function () {
        SphinxRtdTheme.Navigation.enable(true);
      })
</script>

<!-- Temporary footer
<div class="footer-wip">
  <div class="footer-wip-content">
    This documentation refers to an unreleased version of Netket.
  </div>
</div>
-->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118013987-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-118013987-1');
</script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Organization",
  "url": "https://www.netket.org",
  "name": "NetKet",
  "founder": "Giuseppe Carleo",
  "foundingDate": "2018-04-24",
  "foundingLocation" : "New York",
  "logo": "https://www.netket.org/img/logo_small.jpg",
  "sameAs": [
    "https://twitter.com/NetKetOrg",
    "https://github.com/NetKet/netket"
  ],
  "description" : "Netket is an open-source project delivering cutting-edge
  methods for the study of many-body quantum systems with artificial neural
  networks and machine learning techniques."
}
</script>


</body>
</html>